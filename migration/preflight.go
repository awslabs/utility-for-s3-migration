package migration

import (
	"bufio"
	"bytes"
	"context"
	"errors"
	"fmt"
	"io"
	"net/url"
	"os"
	"s3migration/util"
	"strings"

	"github.com/aws/aws-sdk-go-v2/aws"
	"github.com/aws/aws-sdk-go-v2/config"
	"github.com/aws/aws-sdk-go-v2/service/iam"
	"github.com/aws/aws-sdk-go-v2/service/s3"
	s3types "github.com/aws/aws-sdk-go-v2/service/s3/types"
	"github.com/aws/aws-sdk-go-v2/service/s3control"
	s3controltypes "github.com/aws/aws-sdk-go-v2/service/s3control/types"
	"github.com/aws/smithy-go"
	"github.com/google/uuid"
	"github.com/tidwall/gjson"
	"go.uber.org/zap"
)

const (
	s3BatchPrincipalSearch = "Statement.#(Principal.Service==\"batchoperations.s3.amazonaws.com\").Effect"
)

// Use S3 Select to get just the bucket and key from a gzipped CSV generated by the inventory process
func (s3obj *s3migration) checkFilteredManifest(ctx context.Context, bucket string, manifest s3types.Object, localFile string) error {
	manifestJson, err := s3obj.readInventoryManifest(ctx, bucket, manifest)
	if err != nil {
		return err
	}

	csvFile := manifestJson.Files[0].Key
	zap.L().Info("Processing existing inventory datafile",
		zap.String("csvFile", csvFile),
	)
	filters := new(userFilters)
	bucketAndKeyExpression, err := util.GetQueryExpression(manifestJson.FileSchema, filters.StartDate,
		filters.EndDate, filters.LatestOnly, true)
	if err != nil {
		return err
	}
	rdr := s3obj.filterGzippedCsv(ctx, bucket, csvFile, bucketAndKeyExpression)
	if len(localFile) > 0 {
		f, ferr := os.OpenFile(localFile, os.O_RDWR|os.O_CREATE, 0600)
		if ferr != nil {
			zap.L().Error("Unable to create local filtered inventory file", zap.Error(ferr))
		}
		defer f.Close()
		byteCount, _ := io.Copy(f, rdr)
		zap.L().Info("Wrote filtered inventory content to local file",
			zap.Int64("byteCount", byteCount),
		)
	} else {
		lineCount, lerr := LineCounter(rdr)
		if lerr != nil {
			zap.L().Error("Unable to count lines in filtered inventory file", zap.Error(lerr))
		}
		zap.L().Info("Filtered inventory content",
			zap.Int("lineCount", lineCount),
		)
	}
	return nil
}

func checkRoleTrust(ctx context.Context, roleArn string) error {
	// IAM API needs the bare role name, not the ARN
	roleName := roleArn[strings.LastIndex(roleArn, "/")+1:]

	// IAM is a global service hosted out of us-east-1.  Create a new config specific to said region
	cfg, err := config.LoadDefaultConfig(ctx, config.WithRegion("us-east-1"))
	if err != nil {
		zap.L().Fatal(
			"Failed to load AWS client config",
			zap.Error(err),
		)
	}
	client := iam.NewFromConfig(cfg)
	out, ierr := client.GetRole(ctx, &iam.GetRoleInput{
		RoleName: &roleName,
	})
	// ErrorCode of "NoSuchEntity" means the role doesn't exist.
	// Log and bail
	if ierr != nil {
		var ae smithy.APIError
		if errors.As(ierr, &ae) {
			zap.L().Error("GetRole error",
				zap.String("errorCode", ae.ErrorCode()),
				zap.String("errorMessage", ae.ErrorMessage()),
				zap.Error(ierr),
			)
		}
		return ierr
	}
	policyDoc, _ := url.QueryUnescape(*out.Role.AssumeRolePolicyDocument)

	result := gjson.Get(policyDoc, s3BatchPrincipalSearch).String()
	zap.L().Info("Role is assumable by S3 Batch service?",
		zap.Bool("result", result == "Allow"),
	)
	if result != "Allow" {
		return fmt.Errorf("role %s is not assumable by S3 Batch service", roleName)
	}

	return nil
}

// Check that roleArn exists and has trust relationship
func DryRun(sourceRegion, accountID, sourceBucket, roleArn, configName, localFile string) error {
	defer util.ZapLogSync()
	ctx := context.Background()

	cfg, err := config.LoadDefaultConfig(ctx, config.WithRegion(sourceRegion))
	if err != nil {
		zap.L().Fatal(
			"Failed to load AWS client config",
			zap.String("region", sourceRegion),
			zap.Error(err),
		)
	}

	err = checkRoleTrust(ctx, roleArn)
	if err != nil {
		zap.L().Fatal("Failed to check role trust", zap.Error(err))
	}

	s3mig := &s3migration{s3Client: s3.NewFromConfig(cfg)}
	versioningDisabled, verr := s3mig.isVersioningDisabled(ctx, sourceBucket)
	if verr != nil {
		zap.L().Fatal("Failed to get versioning status", zap.Error(verr))
	}
	zap.L().Info("Bucket versioning status",
		zap.String("bucket", sourceBucket),
		zap.Bool("disabled", versioningDisabled),
	)

	manifestArgs, invErr := s3mig.ensureS3InventoryConfig(ctx, sourceBucket, configName, false)
	if invErr != nil {
		zap.L().Fatal("Failed to get inventory config", zap.Error(invErr))
	}
	zap.L().Debug("Search criteria for latest inventory manifest",
		zap.String("bucket", manifestArgs.BucketName),
		zap.String("prefix", manifestArgs.Prefix),
		zap.Int("dateWindow", manifestArgs.DateWindow),
	)

	// Check for latest manifest according to inventory configuration
	var (
		manifestFile *s3types.Object
		merr         error
	)
	manifestFile, merr = s3mig.getLatestManifest(ctx, manifestArgs)
	if merr != nil {
		zap.L().Error("Recoverable error during retrieval of latest inventory manifest",
			zap.Error(merr),
		)
	}
	if manifestFile != nil && manifestFile.Key != nil {
		zap.L().Debug("Found inventory manifest, continuing with dry-run",
			zap.Any("Manifest", manifestFile),
		)
	}

	if versioningDisabled {
		zap.L().Info("Inventory manifest versioning is disabled, filtering manifest file")
		if err := s3mig.checkFilteredManifest(ctx, sourceBucket, *manifestFile, localFile); err != nil {
			zap.L().Error("Recoverable error during retrieval of latest inventory manifest",
				zap.Error(err))
		}
	}

	return nil

}

// Count the number of lines in a reader
// From StackOverflow:  https://stackoverflow.com/questions/24562942
func LineCounter(r io.Reader) (int, error) {

	var count int
	const lineBreak = '\n'

	buf := make([]byte, bufio.MaxScanTokenSize)

	for {
		bufferSize, err := r.Read(buf)
		if err != nil && err != io.EOF {
			return 0, err
		}

		var buffPosition int
		for {
			i := bytes.IndexByte(buf[buffPosition:], lineBreak)
			if i == -1 || bufferSize == buffPosition {
				break
			}
			buffPosition += i + 1
			count++
		}
		if err == io.EOF {
			break
		}
	}

	return count, nil
}

// Build JobInput struct according to reasonable defaults
func NewCreateJobInput(jobArgs *batchJobArgs) *s3control.CreateJobInput {
	spec := &s3controltypes.JobManifestSpec{
		Format: s3controltypes.JobManifestFormatS3InventoryReportCsv20161130,
	}
	if jobArgs.VersioningDisabled {
		spec.Format = s3controltypes.JobManifestFormatS3BatchOperationsCsv20180820
		spec.Fields = []s3controltypes.JobManifestFieldName{"Bucket", "Key"}
	}

	input := &s3control.CreateJobInput{
		AccountId: jobArgs.AccountId,
		Operation: &s3controltypes.JobOperation{
			S3PutObjectCopy: &s3controltypes.S3CopyObjectOperation{
				BucketKeyEnabled:  true,
				MetadataDirective: s3controltypes.S3MetadataDirectiveCopy,
				StorageClass:      s3controltypes.S3StorageClassStandard,
				TargetResource:    util.GetArn(*jobArgs.TargetBucketName),
			},
		},
		Manifest: &s3controltypes.JobManifest{
			Location: &s3controltypes.JobManifestLocation{
				ETag:      jobArgs.ManifestETag,
				ObjectArn: jobArgs.ManifestArn,
			},
			Spec: spec,
		},
		Priority: aws.Int32(10),
		RoleArn:  jobArgs.RoleArn,
		Report: &s3controltypes.JobReport{
			Enabled: false,
		},
		ClientRequestToken:   aws.String(uuid.NewString()),
		ConfirmationRequired: aws.Bool(false),
	}

	return input
}
